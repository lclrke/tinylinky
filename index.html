<!DOCTYPE html>
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Download History</title>
  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.3/lib/p5.min.js"></script>
  <style>
    html, body { margin:0; padding:0; height:100%; background:#0b0e12; overflow:hidden; }
    canvas { display:block; }
  </style>
</head>
<body>
<script>
/*
  p5.js fake Chrome (macOS) "Download History" chaos.

  Controls: mouse wheel to scroll, drag to scroll, space toggles auto-scroll, R resets.
*/

let downloads = [];
let createdCount = 0;

const TARGET_TOTAL = 6000;     // "1000s of files" feel
const BURST_PER_SEC = 240;     // how fast new downloads appear (chaos)
const MAX_VISIBLE_ROWS = 28;   // render only what's visible (virtualized)

let scrollY = 0;
let autoScroll = true;

let lastTime = 0;

function setup() {
  createCanvas(windowWidth, windowHeight);
  textFont('system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial');
  resetAll();
}

function resetAll() {
  downloads = [];
  createdCount = 0;
  scrollY = 0;
  autoScroll = true;
  lastTime = millis();
  // seed initial "already going" pile
  for (let i = 0; i < 140; i++) addDownload(true);
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}

function draw() {
  const now = millis();
  const dt = min(0.05, (now - lastTime) / 1000);
  lastTime = now;

  // Add a lot of new downloads quickly at the top, then keep adding until TARGET_TOTAL.
  if (createdCount < TARGET_TOTAL) {
    const toAdd = floor(BURST_PER_SEC * dt);
    for (let i = 0; i < toAdd; i++) addDownload(false);
  }

  // Update progress and occasional failures
  for (let d of downloads) {
    if (d.state === "downloading") {
      d.progress = min(1, d.progress + d.speed * dt);
      // Random transient stalls/spikes
      if (random() < 0.005) d.speed *= random(0.2, 1.8);
      d.speed = constrain(d.speed, 0.01, 0.45);

      if (d.progress >= 1) {
        d.state = (random() < 0.03) ? "failed" : "complete";
        d.doneAt = now;
      }
    }
  }

  // Auto-scroll downward slightly to make it feel like it's “moving”
  if (autoScroll) scrollY += dt * 220;

  // Bound scroll
  const contentH = downloads.length * rowH() + 220;
  const maxScroll = max(0, contentH - height + 40);
  scrollY = constrain(scrollY, 0, maxScroll);

  renderUI();
}

function renderUI() {
  background(9, 12, 16);

  // Centered macOS Chrome-ish window
  const pad = min(28, width * 0.04);
  const w = min(1100, width - pad * 2);
  const h = min(760, height - pad * 2);
  const x = (width - w) / 2;
  const y = (height - h) / 2;

  // Drop shadow
  noStroke();
  for (let i = 0; i < 18; i++) {
    fill(0, 0, 0, 10);
    rect(x - i*0.6, y - i*0.6, w + i*1.2, h + i*1.2, 18);
  }

  // Window body
  fill(24, 28, 34);
  rect(x, y, w, h, 18);

  // Title bar
  fill(20, 24, 30);
  rect(x, y, w, 62, 18, 18, 10, 10);

  // mac traffic lights
  const cx = x + 20, cy = y + 20, r = 7;
  drawDot(cx + 0, cy, r, color(255, 95, 86));
  drawDot(cx + 20, cy, r, color(255, 189, 46));
  drawDot(cx + 40, cy, r, color(39, 201, 63));

  // Title
  fill(230);
  textSize(18);
  textStyle(BOLD);
  text("Download History", x + 90, y + 26);

  // Search bar
  const sbW = w * 0.52;
  const sbH = 34;
  const sbX = x + w*0.26;
  const sbY = y + 14;
  fill(14, 17, 22);
  rect(sbX, sbY, sbW, sbH, 18);
  fill(160);
  textStyle(NORMAL);
  textSize(13);
  text("Search download history", sbX + 18, sbY + 21);

  // Clear all pill
  const pillW = 92, pillH = 32;
  fill(14, 17, 22);
  rect(x + w - pillW - 18, y + 15, pillW, pillH, 18);
  fill(180);
  textSize(12);
  text("Clear all", x + w - pillW - 18 + 24, y + 35);

  // Subheader
  fill(155);
  textSize(12);
  text("Your profile is managed by BMO", x + w*0.43, y + 56);

  // Content panel
  const contentX = x + 18;
  const contentY = y + 78;
  const contentW = w - 36;
  const contentH = h - 96;

  // Content background
  fill(18, 21, 26);
  rect(contentX, contentY, contentW, contentH, 14);

  // "Today"
  fill(170);
  textSize(12);
  text("Today", contentX + 16, contentY + 26);

  // List viewport (virtualized)
  const listX = contentX + 10;
  const listY = contentY + 40;
  const listW = contentW - 20;
  const listH = contentH - 56;

  // Clip to list
  push();
  drawingContext.save();
  drawingContext.beginPath();
  drawingContext.roundRect(listX, listY, listW, listH, 12);
  drawingContext.clip();

  // Determine visible range
  const rh = rowH();
  const firstIndex = max(0, floor(scrollY / rh));
  const rowsThatFit = ceil(listH / rh) + 2;
  const lastIndex = min(downloads.length - 1, firstIndex + rowsThatFit);

  // Draw rows
  let yy = listY - (scrollY % rh);
  for (let i = firstIndex; i <= lastIndex; i++) {
    drawRow(downloads[i], listX, yy, listW, rh);
    yy += rh;
  }

  drawingContext.restore();
  pop();

  // Status bar
  const active = downloads.filter(d => d.state === "downloading").length;
  const complete = downloads.filter(d => d.state === "complete").length;
  const failed = downloads.filter(d => d.state === "failed").length;

  fill(140);
  textSize(12);
  text(
    `${downloads.length.toLocaleString()} items  •  ${active.toLocaleString()} downloading  •  ${complete.toLocaleString()} complete  •  ${failed.toLocaleString()} failed`,
    contentX + 16, y + h - 16
  );

  // Scrollbar (fake)
  const totalH = downloads.length * rh;
  const thumbH = max(24, listH * (listH / max(listH, totalH)));
  const thumbY = map(scrollY, 0, max(1, totalH - listH), listY, listY + listH - thumbH);
  fill(255, 255, 255, 40);
  rect(listX + listW - 6, thumbY, 4, thumbH, 6);

  // Little hint
  fill(120, 120, 120, 120);
  textSize(11);
  text(
    "Wheel/drag to scroll • Space toggles auto-scroll • R resets",
    x + 18, y + h + 18
  );
}

function drawRow(d, x, y, w, h) {
  const bg = (d.state === "downloading") ? color(30, 34, 41) :
             (d.state === "complete")    ? color(28, 32, 38) :
             (d.state === "failed")      ? color(40, 26, 26) :
                                           color(28, 32, 38);

  noStroke();
  fill(bg);
  rect(x, y + 6, w, h - 10, 12);

  // File icon
  const ix = x + 14, iy = y + h/2;
  fill(240, 240, 240, 50);
  rect(ix, iy - 11, 18, 22, 4);
  fill(240, 240, 240, 25);
  triangle(ix + 12, iy - 11, ix + 18, iy - 5, ix + 18, iy - 11);

  // Filename
  fill(225);
  textSize(13);
  textStyle(BOLD);
  const name = d.name;
  text(clipText(name, w - 240), x + 44, y + 30);

  // Secondary line
  fill(160);
  textStyle(NORMAL);
  textSize(11);

  let line2 = "";
  if (d.state === "downloading") {
    const pct = floor(d.progress * 100);
    line2 = `${pct}%  •  ${fmtMB(d.sizeMB)}  •  ${fmtMB(d.sizeMB * (1 - d.progress))} left  •  ${fmtSpeed(d.speed)}`;
  } else if (d.state === "complete") {
    line2 = `Completed  •  ${fmtMB(d.sizeMB)}`;
  } else if (d.state === "failed") {
    line2 = `Failed – Network error  •  ${fmtMB(d.sizeMB)}`;
  }
  text(line2, x + 44, y + 48);

  // Progress bar
  const barX = x + 44;
  const barY = y + h - 20;
  const barW = w - 170;
  const barH = 6;

  fill(255, 255, 255, 12);
  rect(barX, barY, barW, barH, 99);

  if (d.state === "downloading") {
    fill(80, 160, 255, 130);
    rect(barX, barY, barW * d.progress, barH, 99);
  } else if (d.state === "complete") {
    fill(80, 220, 160, 90);
    rect(barX, barY, barW, barH, 99);
  } else if (d.state === "failed") {
    fill(255, 90, 90, 90);
    rect(barX, barY, barW * 0.45, barH, 99);
  }

  // Right-side actions (fake icons)
  const rx = x + w - 96;
  const cy = y + h/2 + 2;
  drawAction(rx + 0,  cy);
  drawAction(rx + 28, cy);
  drawAction(rx + 56, cy);
}

function drawAction(x, y) {
  fill(255, 255, 255, 20);
  circle(x, y, 18);
  fill(255, 255, 255, 50);
  rect(x - 4, y - 4, 8, 8, 2);
}

function drawDot(x, y, r, c) {
  fill(c);
  circle(x, y, r*2);
  fill(255, 255, 255, 40);
  circle(x - r*0.25, y - r*0.25, r*0.7);
}

function addDownload(seed) {
  if (createdCount >= TARGET_TOTAL) return;

  const exts = ["pdf", "zip", "png", "jpg", "docx", "pptx", "csv"];

  const wordsA = [
    "BMO",
    "Internal",
    "Confidential",
    "Client",
    "Design"
  ];

  const wordsB = [
    "Final",
    "Approved",
    "v2",
    "v3",
    "(1)",
    "(2)",
    "2025",
    "Archive",
    "Review",
    "adrianna+ben pics"
  ];

  const w1 = random(wordsA);
  const w2 = random(wordsB);
  const ext = random(exts);

  const d = {
    id: createdCount++,
    name: `${w1} ${w2} ${nf(floor(random(0, 9999)), 4)}.${ext}`,
    sizeMB: random(0.2, 2200),
    progress: seed ? random(0.05, 0.85) : random(0.0, 0.12),
    speed: seed ? random(0.03, 0.25) : random(0.08, 0.38),
    state: "downloading",
    doneAt: null
  };

  if (seed && random() < 0.08) {
    d.state = "complete";
    d.progress = 1;
  }

  if (seed && random() < 0.015) {
    d.state = "failed";
    d.progress = random(0.2, 0.8);
  }

  downloads.unshift(d);

  if (downloads.length > TARGET_TOTAL) {
    downloads.pop();
  }
}

function rowH() { return 78; }

function fmtMB(mb) {
  if (mb < 1) return `${floor(mb * 1024)} KB`;
  if (mb < 1024) return `${mb.toFixed(mb < 10 ? 2 : 1)} MB`;
  const gb = mb / 1024;
  if (gb < 1024) return `${gb.toFixed(gb < 10 ? 2 : 1)} GB`;
  const tb = gb / 1024;
  return `${tb.toFixed(2)} TB`;
}

function fmtSpeed(p) {
  // p is progress/sec; map to a plausible MB/s based on file size distribution
  const mbps = (p * 900); // just a vibe, not physics
  if (mbps < 1) return `${(mbps*1024).toFixed(0)} KB/s`;
  if (mbps < 1024) return `${mbps.toFixed(1)} MB/s`;
  return `${(mbps/1024).toFixed(2)} GB/s`;
}

function clipText(str, maxPx) {
  // approximate width clipping
  let s = str;
  while (textWidth(s) > maxPx && s.length > 8) s = s.slice(0, -2);
  if (s !== str) return s + "…";
  return s;
}

// Input
let dragging = false;
let lastMouseY = 0;

function mouseWheel(e) {
  autoScroll = false;
  scrollY += e.delta;
  return false;
}

function mousePressed() {
  dragging = true;
  lastMouseY = mouseY;
}

function mouseReleased() {
  dragging = false;
}

function mouseDragged() {
  autoScroll = false;
  const dy = mouseY - lastMouseY;
  scrollY -= dy;
  lastMouseY = mouseY;
}

function keyPressed() {
  if (key === ' ') autoScroll = !autoScroll;
  if (key === 'r' || key === 'R') resetAll();
}
</script>
</body>
</html>